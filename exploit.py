# ----------- ACE Template ----------- #

from pwn import *
import subprocess
import requests
import angr
import os

# Access token for team to make api calls -- CHANGE THIS
access_token = "INSERT API TOKEN"

# URL of ctfd --  CHANGE THIS
ctfd_url = "https://ace.ctfd.io"

# Headers needed for api calls
headers = {
    "Authorization": f"Token {access_token}",
    "Content-Type" : "application/json",
}


# ------------------------------------------------- #
# This is where your auto exploit code should be    #
# placed. This should craft the exploit locally to  #
# get the fake flag, send the exploit to the remote #
# binary, receive the flag, and submit the flag     #
# ------------------------------------------------- #

def exploit(file_path: str, chal_id):
    e = ELF(file_path)
    p = process(file_path)
    # EXPLOITATION!

    # -- This is an example payload -- #
    payload = b"GottaReverseMe!"
    
    # ----- Send payload locally ----- #
    p.sendline(payload)

    # --- Receive the flag locally --- #
    local_flag = p.recvline().strip()

    if local_flag == "flag{fake-flag}"
        addr, port = get_remote(chal_id)
        send_exploit(addr, int(port), payload, chal_id)
    else:
        print(f"Couldn't exploit {file_path}!")

# ------------------------------------------------- #
# This function gets the correct addr and port to   #
# connect to so that you can send your exploit to   #
# to the remote service running on that port        #
# ------------------------------------------------- #

def get_remote(chal_id):
    challenge_url = f"{ctfd_url}/api/v1/challenges/{chal_id}"
    response = requests.get(challenge_url, headers=headers)
    if response.status_code == 200:
        challenge_data = response.json()
        remote = challenge_data.get("data", {}).get("description").split(' ')
        return remote[1], remote[2]
    else:
        return None, None

# ------------------------------------------------- #
# This function will send the payload to the remote #
# service running on that address and port          #
# ------------------------------------------------- #

def send_exploit(addr, port, payload, chal_id):
    p = remote(addr, port)
    # p.recvuntil(">>")     # Will this signify ready to recv?
    p.sendline(payload)
    p.recvline()            # NOTE # This needs to be standardized 
    p.recvline()
    flag = p.recvline().strip().decode()
    send_flag(flag, chal_id)    
    
# ------------------------------------------------- #
# This function will submit the flag to CTFd        #
# ------------------------------------------------- #

def patch_local_bins():
    # todo

 
def send_flag(flag, chal_id):
    challenge_url = f"{ctfd_url}/api/v1/challenges/attempt"
    data = json.dumps({"challenge_id" : chal_id, "submission" : flag})
    response = requests.post(challenge_url, headers=headers, data=data)

if __name__ == "__main__":
    
    # Var for rounds
    round_number = 1

    # ----- Download Binary Repo ----- #
    try:
        subprocess.run("git clone https://github.com/tj-oconnor/ace-binaries.git", shell=True)
        os.chdir("ace-binaries")
    except Exception as e:
        print("Failed to clone git repo!")
    # -------------------------------- #


    # ----- Get the first chal id ---- #
    challenge_url = f"{ctfd_url}/api/v1/challenges"
    response = requests.get(challenge_url, headers=headers)
    start_id = json.loads(response.text).get("data", {})[0].get("id")
    # -------------------------------- #


    # ----- Main Execution Loop! ----- #
    while(1):
        # Pull from repo to check for new rounds
        subprocess.run("git pull", shell=True)
        patch_local_bins() # <--- patch all binaries with /opt/libc 

        # Find new rounds that are pulled
        if f"round-{round_number}" in os.listdir(os.getcwd()):
            
            # For-loop for per-round exploitation
            for binary in os.listdir(f"round-{round_number}"):
                try:
                    # Call exploit with id of each challenge to submit flag
                    exploit(f"./round-{round_number}/{binary}", start_id)
                except Exception as e:
                    print(f"Failed to exploit {file}: {e}")
                start_id += 1
            round_number += 1
        else:
            sleep(1)
        
        if round_number == 12:
            break
    # -------------------------------- #

    print("All Done!")


